# 4 QTRAN

## 1 概述

**定义：IGM (Individual-Global-Max)**

![](img/2020-08-05-20-24-40.png)


**算法演变：**
- 去中心化方法，可扩展性好，但是存在不稳定问题；
- 中心化方法：可以解决非稳定问题，但是随智能体增加，复杂性爆炸；
- MADDPG：学习在连续动作空间学习分布式策略；
- COMA：Actors用联合critic估计反事实baseline解决信用（贡献）分配问题；
- 值分解方法：解决联合Q值随着智能体数量增加，复杂性爆炸增加的问题，
  - VDN：加性约束，
  - ![](img/2020-08-05-20-25-25.png)
  - QMIX：单调性约束。
  - ![](img/2020-08-05-20-25-47.png)

**本文目标**:

可分解任务定义为，联合Q值取得得最优动作也是个体Q值得最优动作。使用加性限制和单调性限制有点过度限制了，限制了智能体的种类;

本文把原始联合Q值函数$$Q_{jt}$$转换为新的$$Q_{jt}'$$，使其与$$Q_{jt}$$具有相同的最优动作，并解除加性/单调性约束。

**本文贡献**:
- 通过学习一个状态值函数（用来更正部分观察带来得偏差），把原始联合动作值函数转化为新的易分解形式,且最优动作保持相同;
- QTRAN算法：联合动作值网络、个体动作值网络、状态网络，定义每个网络得loss函数；
- QTRAN变体：QTRAN-base和QTRAN-alt
  - 不同点：如何构造非最优动作的转换Q函数
  - 收敛速度和稳定性
- 在三个环境测试算法。

## 2 算法原理

### 2.1 因子函数$$[Q_i]$$的条件

$$\pmb{\mu}$$

定义$$\bar{\mu}_i=\argmax_{\mu_i}Q_i(\tau_i, \mu_i)$$表示最优动作，$$\bar{\pmb{\mu}}=[\bar{\mu}_i]_{i=1}^{N}$$；令$$\mathbf{Q}=[Q_i]\in \mathbb{R}^N$$，即$$Q_i, i = 1,...,N$$的列向量。

**定理1** 给出$$[Q_i]$$满足**IGM**的条件。

|一个可分的联合Q值函数$$Q_{jt}(\pmb{\tau}, \pmb{\mu})$$，可以被$$[Q_i(\tau_i, \mu_i)]$$分解，当 |
|:-|
| ![](img/2020-08-05-20-43-45.png) |

<!-- 给定联合观察$$\pmb{\tau}$$，考虑任意可因式分解函数$$Q_{jt}(\pmb{\tau}, \pmb{\mu})$$。通过**定义1**我们可以找到个体Q函数$$[Q_i(\tau_i, \mu_i)]$$分解$$Q_{jt}$$。**定义1**说明了$$[Q_i]$$满足**IGM**的条件。 -->

注意，(4)中的条件在仿射变换的情况下是必要的。也就是说，存在一个仿射变换$$\phi(\mathbf{Q}) = A\cdot \mathbf{Q}+B$$（其中$$A=[a_{ii}] \in \mathbb{R}_+^{N\times N}$$是$$a_{ii}>0$$的对称对角矩阵，$$B=[b_i]\in \mathbb{R}^N$$），使得当$$Q_{jt}$$可以被$$[Q_i]$$分解时，把$$Q_i$$替换成$$a_{ii}Q_i+b_i$$时，则(4)成立。这是因为对于所有的i，$$b_i$$都抵消掉，$$a_{ii}$$仅仅作为$$\sum_{i=1}^N Q_i$$的缩放因子，因为**IGM**是不变的。

**变换分解：**首先定义加性的**变换联合Q值函数函数**，

$$
Q'_{jt}(\pmb{\tau}, \pmb{\mu}) \coloneqq \sum\limits_{i=1}^{N} Q_i(\tau_i, \mu_i)
$$

通过加性结构，$$[Q_i]$$满足$$Q'_{jt}$$的IGM，那么它就是$$Q'_{jt}$$的分解个体Q值函数。因为$$\argmax_{\pmb{\mu}}Q_{jt}(\pmb{\tau}, \pmb{\mu})= \argmax_{\pmb{\mu}}Q'_{jt}(\pmb{\tau}, \pmb{\mu})$$，找到$$[Q_i]$$满足(4)就是$$Q'_{jt}(\pmb{\tau}, \pmb{\mu})$$的分解。

函数$$V_{jt}(\pmb{\tau})$$用来修正中心化联合Q函数$$Q_{jt}$$和$$[Q_i]$$的和的偏差。偏差是智能体部分观察带来的。如果加入了全局观察，$$V_{jt}$$可以设为0。

### 2.2 算法


